# Parte A — Respuestas teórico‑conceptuales

## A1. Monorepo vs. repositorios múltiples (~200 palabras)
Un **monorepo** acelera el arranque porque unifica discoverability (todo está en un solo lugar), reduce la fricción inicial (un único `README`, tooling común, un solo pipeline de CI) y facilita **bootstrap** de equipos junior: basta clonar y ejecutar. Sin embargo, a medida que crece el número de colaboradores, empiezan a emerger costes ocultos: *locks* simultáneos sobre archivos críticos (por ejemplo, `providers.tf`), colas de revisión interminables, CI más lento por ejecutar pipelines masivos para cambios pequeños, y permisos demasiado amplios (cualquiera con `write` puede tocar módulos sensibles). Además, cualquier “breaking change” en un módulo central rompe consumidores en cascada.
Extraer un módulo (p. ej., `modules/network/`) a su propio repositorio con **versionado independiente** reduce acoplamiento y delimita **propiedad**. Flujo sugerido: (1) aislar el directorio y dependencias; (2) **filtrar historial** con `git filter-repo`/`git subtree split` para conservar trazabilidad; (3) crear su **pipeline propio** (plan→policy→sbom→release); (4) publicar **`v1.0.0`** firmada y actualizar consumidores para que dependan de etiquetas semánticas en lugar de `main`. El resultado es menor contención, revisiones más enfocadas, permisos precisos por **dominio** y CI proporcional al tamaño del módulo.

## A2. Versionado semántico y notas de versión (~150 palabras)
Publicar `v1.0.0` afirma un **contrato estable**: variables, salidas y comportamientos compatibles. El **número mayor** (`2.0.0`) sube cuando hay *breaking changes* (variables renombradas/eliminadas, outputs cambiantes, defaults inseguros corregidos que exigen acción). El **número menor** (`1.1.0`) sube cuando agregas **capacidades compatibes** (nueva variable opcional, soporte de una región extra) sin romper consumidores. El **patch** (`1.1.1`) corrige defectos sin alterar el contrato (p. ej., `lifecycle` ausente, etiquetas faltantes).
Apuntar a `main` es inaceptable en producción: no hay **inmutabilidad** ni **reproducibilidad**. Los equipos deben fijar **etiquetas firmadas** (`git tag -s`) y verificar firmas en CI. Una buena **release note** resume impacto operativo, cambios de entradas/salidas, migración paso a paso, riesgos conocidos, *fallback* y, si aplica, pasos manuales temporales. Debe incluir hash del commit, firma, referencias a issues y a reportes de políticas/SBOM.

## A3. Seguridad en cadena de suministro (~200 palabras)
1) **SBOM + verificación de proveedores**: un SBOM lista *providers*, módulos y binarios usados. Verificarlos (checksums/firma, mirrors internos) evita “proveedores manipulados”, *typosquatting* o sustitución maliciosa. 2) **SLSA / procedencia firmada**: cada release debe responder *qué commit*, *qué pipeline* y *qué identidad* generó el artefacto. Firmar el paquete (sigstore/cosign, GPG) y adjuntar *attestations* permite a CI y a auditores validar **procedencia** (SLSA v1+). 3) **Solo etiquetas firmadas en prod**: el *gate* de despliegue rechaza módulos sin firma válida o con procedencia ambigua. En conjunto, esto reduce **riesgo de suplantación** y **drift** no autorizado, proporciona trazabilidad *end‑to‑end* y facilita respuesta a incidentes (¿quién introdujo el cambio?, ¿cuándo?, ¿qué dependencias?). Integrado al pipeline de IaC (plan→policy→sbom→release), convierte a la cadena de suministro en una **superficie controlada**, no en un “mercado libre” de binarios.

## A4. Secretos y privilegio mínimo (~200 palabras)
Errores típicos: subir `AWS_ACCESS_KEY` al repo, imprimir credenciales en *outputs*, reutilizar la misma clave entre `dev` y `prod`, o dar permisos de *admin* por comodidad. Flujo correcto: (1) **gestor centralizado de secretos** (AWS Secrets Manager, Vault, GCP SM) con recuperación dinámica en CI; (2) **rotación frecuente** y TTL corto; (3) **scoping por entorno**: credenciales distintas para `dev/staging/prod` y *namespaces* separados; (4) *checks* automáticos que fallen si un `output` coincide con patrones de secreto (gitleaks/trufflehog) o si una política OPA detecta recursos públicos sin justificación. Relacionado con **privilegio mínimo**: cada *principal* (pipeline, módulo, persona) recibe solo los permisos estrictamente necesarios (IAM granular, `assumeRole` para tareas puntuales, *boundary policies*). Todo debe ser **auditable**: quién accedió a cada secreto, cuándo y desde qué pipeline; reportes periódicos de rotación, *access analyzer* y listas de *environments-to-permissions* comprobables.

## A5. Evidencia y auditoría (~150 palabras)
En IaC no basta “confía en mí”: la **evidencia** reemplaza la fe. Mínimos a retener por cambio: (a) **SBOM** con hash; (b) **resultado de escaneo de secretos** (0 hallazgos críticos o justificación/risk‑acceptance firmado); (c) hash del `tfstate` y traza **plan/apply** (quién ejecutó, cuándo, qué dif); (d) reporte de **drift** detectado y, si se corrige, evidencia del *apply* que lo resolvió. Asociar cada artefacto con fecha, commit y responsable permite mapear controles técnicos a marcos normativos (ISO 27001, NIST 800‑53, PCI DSS). Así las auditorías se vuelven **reproducibles**, sin teatro: el auditor verifica hashes, firmas y procedencia y obtiene la misma vista que el equipo.